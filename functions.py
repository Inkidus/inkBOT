from strings import *

import logging
import os
import discord
import openai
import requests
import datetime
import asyncio
import pyttsx3

from dotenv import load_dotenv
from collections import OrderedDict
from discord.ext import commands
from openai.error import InvalidRequestError
from openai.error import RateLimitError


# Function will take a message over 2000 characters generated by the chatbot and split it
async def send_long_message(message_content, channel):
	while message_content:
		split_index = message_content.rfind('\n', 0, 2000)
		if split_index == -1:
			split_index = 2000

		part = message_content[:split_index]
		message_content = message_content[split_index:].lstrip('\n')

		await channel.send(part)

# Function will read the contents of freegames.txt and use them to distribute a list of temporarily free games to a predefined list
async def freeGamesPost(originalMessage, client, free_game_channels):
	async with originalMessage.channel.typing():
		with open("freegames.txt", "r") as file:
			lines = file.readlines()

		deals = {}
		current_website = None

		for line in lines:
			line = line.strip()
			if not line:
				continue

			if line.endswith(':'):
				current_website = line[:-1]
				deals[current_website] = []
			else:
				deals[current_website].append(line)

		response = "__Here's some new (temporarily) free games to add to your accounts:__"
		for website, website_deals in deals.items():
			response += f"\n**From {website}:**\n"
			for deal in website_deals:
				response += f"{deal}\n"

		for channel_id in free_game_channels:
			target_channel = client.get_channel(channel_id)
			await target_channel.send(response)

# Function will display a list of the bot's commands or specific information concerning a single command
async def helpPost(originalMessage):
	async with originalMessage.channel.typing():
		user_content  = originalMessage.content[12:].strip()
		if not user_content:
			await originalMessage.channel.send(DEFAULT_HELP)
		elif user_content.lower() == 'become':
			await originalMessage.channel.send(BECOME_HELP)
		elif user_content.lower() == 'select':
			await originalMessage.channel.send(SELECT_HELP)
		elif user_content.lower() == 'forget':
			await originalMessage.channel.send(FORGET_HELP)
		elif user_content.lower() == 'draw':
			await originalMessage.channel.send(DRAW_HELP)
		elif user_content.lower() == 'join':
			await originalMessage.channel.send(JOIN_HELP)
		elif user_content.lower() == 'leave':
			await originalMessage.channel.send(LEAVE_HELP)
		elif user_content.lower() == 'tts':
			await originalMessage.channel.send(TTS_HELP)
		else:
			await originalMessage.channel.send(UNKNOWN_HELP)

# Function will make the bot join the voice channel of the sender, if they are in one accessible by the bot
async def vcJoin(originalMessage):
	logging.info(f"User ID: {originalMessage.author.id} - Requested joining of voice channel: {originalMessage.author.voice.channel}\n")
	async with originalMessage.channel.typing():
		if originalMessage.author.voice is not None:
			try:
				await originalMessage.channel.send(f"Joining your voice chat")
				voice_client = await originalMessage.author.voice.channel.connect()
			except discord.errors.ClientException:
				await originalMessage.channel.send("Sorry, looks like I'm in another voice chat")
		else:
			await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")

# Function will make the bot leave its current voice channel, if it is in one
async def vcLeave(originalMessage):
	logging.info(f"User ID: {originalMessage.author.id} - Requested leaving of voice channel: {originalMessage.author.voice.channel}\n")
	async with originalMessage.channel.typing():
		if originalMessage.guild.voice_client:
			await originalMessage.channel.send(f"Alright, leaving my current voice chat...")
			await originalMessage.guild.voice_client.disconnect()
		else:
			await originalMessage.channel.send("Sorry, I don't think I'm in a voice chat right now")

# Function will make the bot speak some words out loud in a voice channel
async def ttsSpeak(originalMessage):
	logging.info(f"User ID: {originalMessage.author.id} - Requested tts of: {originalMessage.content}\n")
	if not originalMessage.author.voice:
		await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")
	elif not originalMessage.guild.voice_client:
		await originalMessage.channel.send("Sorry, I don't think I'm in a voice chat right now")
	else:
		user_content  = originalMessage.content[11:].strip()
		await text_to_speech(user_content, originalMessage)

# Function will clear part/all of the message history the bot has stored for a specific channel
async def chatForget(originalMessage, chat_histories):
	async with originalMessage.channel.typing():
		if originalMessage.channel.id in chat_histories:
			if originalMessage.content.lower().startswith('inkbot4'):
				user_content  = originalMessage.content[15:].strip()
			elif originalMessage.content.lower().startswith('inkbot'):
				user_content  = originalMessage.content[14:].strip()
			
			if not user_content:
				chat_histories.pop(originalMessage.channel.id)
				await originalMessage.channel.send("Understood, clearing all memory from this channel and reverting to my default personality.")
			else:
				numToErase = int(user_content) * 2
				for i in range(numToErase):
					chat_histories[originalMessage.channel.id].pop(2)
				await originalMessage.channel.send("Understood, clearing " + user_content + " prompts and their responses from this channel.")
		else:
			await originalMessage.channel.send("Sorry, I couldn't find any memories from this channel.")

# Function will override the chatbot's default personality
async def chatBecome(originalMessage, chat_histories):
	async with originalMessage.channel.typing():
		logging.info(f"User ID: {originalMessage.author.id} - Submitted New Personality: {originalMessage.content}\n")
		
		if originalMessage.content.lower().startswith('inkbot4:'):
			newPersonality  = originalMessage.content[15:].strip()
		elif originalMessage.content.lower().startswith('inkbot:'):
			newPersonality  = originalMessage.content[14:].strip()
		else:
			newPersonality = originalMessage.content

		custom_system_message = [
			{"role": "system", "content": newPersonality},
			{"role": "system", "content": TEXT_FORMAT},
		]

		if originalMessage.channel.id not in chat_histories:
			chat_histories[originalMessage.channel.id] = custom_system_message.copy()
			await originalMessage.channel.send("Successfully adopted my new personality.")
		else:
			chat_histories.pop(originalMessage.channel.id)
			chat_histories[originalMessage.channel.id] = custom_system_message.copy()
			await originalMessage.channel.send("Successfully cleared all memories of this channel and adopted my new personality.")

# Function will call chatBecome with some preset personality
async def chatSelect(originalMessage, chatHistories):
	async with originalMessage.channel.typing():
	
		tempMessage = originalMessage
	
		if originalMessage.content.lower().startswith('inkbot4:'):
			user_content  = originalMessage.content[15:].strip()
		elif originalMessage.content.lower().startswith('inkbot:'):
			user_content  = originalMessage.content[14:].strip()
	
		if not user_content:
			await originalMessage.channel.send("Please include the pre-defined personality you would like me to adopt.")
		elif user_content.lower() == 'original':
			await originalMessage.channel.send("Setting predefined personality: original.")
			tempMessage.content = SELECT_ORIGINAL
			await chatBecome(tempMessage, chatHistories)
		elif user_content.lower() == 'art prompt':
			await originalMessage.channel.send("Setting predefined personality: art prompt generator")
			tempMessage.content = SELECT_ARTPROMPT
			await chatBecome(tempMessage, chatHistories)
			
		else:
			await originalMessage.channel.send("Sorry, that does not appear to be one of my pre-defined personalities.")


# Function will generate and post an image in response to an input prompt
async def dallePost(originalMessage):
	async with originalMessage.channel.typing():
		try:
			image_response = openai.Image.create(
				prompt = originalMessage.content[12:].strip(), 
				n = 1, 
				size = "1024x1024" # Can be 256, 512, 1024
			)
			logging.info(f"User ID: {originalMessage.author.id} - Requested Image: {originalMessage.content}, ")
			logging.info(f"received {image_response['data'][0]['url']}\n")
			await originalMessage.channel.send("Image generated!\n**Prompt:** " + originalMessage.content[12:].strip())
			await originalMessage.channel.send(image_response['data'][0]['url'])
		except InvalidRequestError:
			await originalMessage.channel.send("Sorry, your prompt was unsafe. Please review the content policy: <https://labs.openai.com/policies/content-policy>")
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Unsafe Image Prompt: {originalMessage.content}, ")

# Function will generate a response to some input prompt
async def chatPost(originalMessage, chat_histories, default_system_message, modelRequested):
	async with originalMessage.channel.typing():
		isPromptSafe = await is_message_safe(originalMessage.content)

		if isPromptSafe:
			if originalMessage.content.lower().startswith('inkbot,'):
				user_content  = originalMessage.content[7:].strip()
			if originalMessage.content.lower().startswith('inkbot4,'):
				user_content  = originalMessage.content[8:].strip()
			if originalMessage.content.lower().startswith('dinklebot,'):
				user_content  = originalMessage.content[10:].strip()
			if originalMessage.content.lower().startswith('dinklebot4,'):
				user_content  = originalMessage.content[11:].strip()
			
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Prompt: {user_content}\n")
			
			if originalMessage.channel.id not in chat_histories:
				chat_histories[originalMessage.channel.id] = default_system_message.copy()

			try:
				current_date = datetime.datetime.now().strftime("%B %d, %Y")
				current_time = datetime.datetime.now().strftime("%I:%M:%S %p")
				time_of_response = f"""The current date is {current_date}. The current time is {current_time}."""

				completion_messages = chat_histories[originalMessage.channel.id] + [{"role": "system", "content": time_of_response}] + [{"role": "user", "content": user_content}]
				
				returnedCompletion = openai.ChatCompletion.create(
					model=modelRequested,
					messages=completion_messages,
					top_p=0.1,
				)
			except InvalidRequestError:
				try:
					for i in range(8):
						chat_histories[originalMessage.channel.id].pop(2)
					
					completion_messages = chat_histories[originalMessage.channel.id] + [{"role": "user", "content": user_content}]
					returnedCompletion = openai.ChatCompletion.create(
						model=modelRequested,
						messages=completion_messages,
						top_p=0.1,
					)
				except InvalidRequestError:
					await originalMessage.channel.send("Sorry, could not generate response. Please use try again after clearing some messages from my memory.")
				except RateLimitError:
					await originalMessage.channel.send("Sorry, the rate limit has been reached, please wait a bit before trying again.")
			except RateLimitError:
				await originalMessage.channel.send("Sorry, the rate limit has been reached, please wait a bit before trying again.")
			
			response = returnedCompletion.choices[0].message.content.strip()
			isResponseSafe = await is_message_safe(response)

			if isResponseSafe:
				logging.info(f"Response: {response}\n")
				
				if ((len(chat_histories[originalMessage.channel.id]) == 12) and (modelRequested == "gpt-4")):
					for i in range(2):
						chat_histories[originalMessage.channel.id].pop(2)
				
				chat_histories[originalMessage.channel.id].extend([
					{"role": "user", "content": user_content},
					{"role": "assistant", "content": response},
				])
				
				if len(response) > 2000:
					await send_long_message(response, originalMessage.channel)
				else:
					await originalMessage.channel.send(response)
			
			else:
				logging.info(f"Unsafe Response Generated: {response}\n")
				await originalMessage.channel.send("Sorry, the response was unsafe, not your fault at all though.")
		else:
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Unsafe Prompt: {originalMessage.content}\n")
			await originalMessage.channel.send("Sorry, your prompt was unsafe. Please review the usage policy: <https://openai.com/policies/usage-policies>")


async def generate_tts_file(message):
	engine = pyttsx3.init()
	voices = engine.getProperty('voices')
	engine.setProperty('voice', voices[0].id)

	if os.path.exists('tospeak.wav'):
		os.remove('tospeak.wav')

	engine.save_to_file(message, 'tospeak.wav')
	engine.runAndWait()

	engine.stop()


async def text_to_speech(message, original_message):
	await generate_tts_file(message)
	
	while not os.path.exists('tospeak.wav'):
		await asyncio.sleep(0.1)
	
	current_size = os.path.getsize('tospeak.wav')
	await asyncio.sleep(2)
	new_size = os.path.getsize('tospeak.wav')
	
	while current_size != new_size:
		current_size = new_size
		await asyncio.sleep(2)
		new_size = os.path.getsize('tospeak.wav')
	
	original_message.guild.voice_client.play(source = discord.FFmpegPCMAudio('tospeak.wav'))


async def is_message_safe(message):
	response = openai.Moderation.create(
		input = message
	)

	results = response["results"]
	flagged = results[0]["flagged"]
	logging.info(f"Were scanned contents flagged? {flagged}\n")
	return not flagged