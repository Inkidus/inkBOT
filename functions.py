from strings import *

import logging
import os
import discord
import openai
import requests
import datetime
import asyncio
import pyttsx3
import random
import yt_dlp
import yaml
import json
import base64

from dotenv import load_dotenv
from collections import OrderedDict
from discord.ext import commands
from discord import FFmpegPCMAudio
from discord.ext.commands import CommandNotFound
from openai.error import InvalidRequestError
from openai.error import RateLimitError
from openai.error import APIError
from openai.error import APIConnectionError
from openai.error import AuthenticationError
from openai.error import Timeout
from openai.error import ServiceUnavailableError
from google.cloud import texttospeech


# Retrieve API and ID information from values.env
load_dotenv('values.env')

DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
GOOGLE_API_KEY = os.getenv('GOOGLE_CLOUD_TTS_API_KEY')

free_game_ids = int(os.getenv('FREEGAMEID'))
free_game_channels = [
	int(os.getenv('CHANNEL1')),
	int(os.getenv('CHANNEL2')),
	int(os.getenv('CHANNEL3')),
	int(os.getenv('CHANNEL4')),
	int(os.getenv('CHANNEL5')),
	int(os.getenv('CHANNEL6'))
]

openai.api_key = OPENAI_API_KEY


# Establish default entry for chatbot memory
defaultHistoryEntry = [
	{"role": "system", "content": DEFAULT_PERSONALITY},
	{"role": "system", "content": TEXT_FORMAT},
]


# Establish storage for chatbot memory/sessions and media queues, then load if they exist
mediaQueues = dict()
chatHistories = dict()
chatSessions = dict()
webHistories = dict()


if os.path.exists('storedHistories.yaml'):
	with open('storedHistories.yaml', 'r') as file:
		data = yaml.load(file, Loader=yaml.FullLoader)
		chatHistories = data['chatHistories']

if os.path.exists('storedWebHistories.yaml'):
	with open('storedWebHistories.yaml', 'r') as file:
		data = yaml.load(file, Loader=yaml.FullLoader)
		webHistories = data['webHistories']

if os.path.exists('storedSessions.yaml'):
	with open('storedSessions.yaml', 'r') as file:
		data = yaml.load(file, Loader=yaml.FullLoader)
		chatSessions = data['sessionList']


# Function will take a message over 2000 characters generated by the chatbot and split it
async def send_long_message(message_content, channel):
	while message_content:
		split_index = message_content.rfind('\n', 0, 2000)
		if split_index == -1:
			split_index = 2000
		
		part = message_content[:split_index]
		message_content = message_content[split_index:].lstrip('\n')
		
		await channel.send(part)

# Function will send the results of a dice roll
async def dicePost(originalMessage):
	async with originalMessage.channel.typing():
		# Extract the number of sides
		prompt = originalMessage.content[12:].strip()
		
		# If no input provided
		if not prompt:
			await originalMessage.reply("Rolling a void dice... You rolled nothing!\n(Please include a number next time!)")
		
		# If some input was provided
		else:
			try:
				side_number = int(prompt)
				if side_number < 0:
					roll_result = random.randint(side_number, -1)
					await originalMessage.reply(f'Rolling an anti-dice with {side_number} sides...\nYou rolled a **{roll_result}**!')
				elif side_number == 0:
					await originalMessage.reply(f'Rolling a 0-sided dice...\nHuh, the dice disappeared...')
				elif side_number == 1:
					await originalMessage.reply(f'Rolling a 1-sided dice...\nYou rolled a **1**!')
				else:
					roll_result = random.randint(1, int(side_number))
					await originalMessage.reply(f'Rolling a {side_number}-sided dice...\nYou rolled a **{roll_result}**!')
			except ValueError:
				await originalMessage.reply("How do I even begin simulating a dice like that?")

# Function will send the results of a coinflip
async def coinPost(originalMessage):
	async with originalMessage.channel.typing():
		randomInt = random.randint(1, 6001)
		if randomInt == 3001:
			await originalMessage.reply(f'Flipping a coin...\nIt landed on **its side**?')
		elif randomInt < 3001:
			await originalMessage.reply(f'Flipping a coin...\n**Heads**!')
		elif randomInt > 3001:
			await originalMessage.reply(f'Flipping a coin...\n**Tails**!')
		else:
			await originalMessage.reply(f"Flipping a coin...\nHuh, the coin disappeared...")

# Function will read the contents of freegames.txt and use them to distribute a list of temporarily free games to a predefined list
async def freeGamesPost(originalMessage, bot, free_game_channels):
	async with originalMessage.channel.typing():
		# Open the file where free games are stored
		with open("freegames.txt", "r") as file:
			lines = file.readlines()
		
		# Set up temporary variables
		deals = {}
		current_website = None
		
		# Extract information from the file
		for line in lines:
			line = line.strip()
			if not line:
				continue
		
			if line.endswith(':'):
				current_website = line[:-1]
				deals[current_website] = []
			else:
				deals[current_website].append(line)
		
		# Generate the message which will be sent
		response = "__Here's some new (temporarily) free games to add to your accounts:__"
		for website, website_deals in deals.items():
			response += f"\n**From {website}:**\n"
			for deal in website_deals:
				response += f"{deal}\n"
		
		# For each channel saved, send the message
		for channel_id in free_game_channels:
			target_channel = bot.get_channel(channel_id)
			await target_channel.send(response)

# Function will display a list of the bot's commands or specific information concerning a single command
async def helpPost(originalMessage):
	async with originalMessage.channel.typing():
		# Extract the context provided
		user_content = originalMessage.content[12:].strip()
		
		# Respond depending on the context provided
		if not user_content:
			await originalMessage.channel.send(DEFAULT_HELP)
		elif user_content.lower() == 'learn':
			await originalMessage.channel.send(LEARN_HELP)
		elif user_content.lower() == 'forget':
			await originalMessage.channel.send(FORGET_HELP)
		elif user_content.lower() == 'become':
			await originalMessage.channel.send(BECOME_HELP)
		elif user_content.lower() == 'select':
			await originalMessage.channel.send(SELECT_HELP)
		elif user_content.lower() == 'session start':
			await originalMessage.channel.send(START_SESSION_HELP)
		elif user_content.lower() == 'session stop':
			await originalMessage.channel.send(STOP_SESSION_HELP)
		elif user_content.lower() == 'session modify':
			await originalMessage.channel.send(MODIFY_SESSION_HELP)
		elif user_content.lower() == 'draw':
			await originalMessage.channel.send(DRAW_HELP)
		elif user_content.lower() == 'join':
			await originalMessage.channel.send(JOIN_HELP)
		elif user_content.lower() == 'leave':
			await originalMessage.channel.send(LEAVE_HELP)
		elif user_content.lower() == 'tts':
			await originalMessage.channel.send(TTS_HELP)
		elif user_content.lower() == 'play':
			await originalMessage.channel.send(PLAY_HELP)
		elif user_content.lower() == 'pause':
			await originalMessage.channel.send(PAUSE_HELP)
		elif user_content.lower() == 'resume':
			await originalMessage.channel.send(RESUME_HELP)
		elif user_content.lower() == 'stop':
			await originalMessage.channel.send(STOP_HELP)
		elif user_content.lower() == 'skip':
			await originalMessage.channel.send(SKIP_HELP)
		elif user_content.lower() == 'queue':
			await originalMessage.channel.send(QUEUE_HELP)
		elif user_content.lower() == 'cancel':
			await originalMessage.channel.send(CANCEL_HELP)
		else:
			await originalMessage.channel.send(UNKNOWN_HELP)

# Function will make the bot join the voice channel of the sender, if they are in one accessible by the bot
async def vcJoin(originalMessage):
	async with originalMessage.channel.typing():
		if originalMessage.author.voice is not None:
			try:
				voice_client = await originalMessage.author.voice.channel.connect()
				logging.info(f"User ID: {originalMessage.author.id} - Successfully Requested joining of voice channel: {originalMessage.author.voice.channel}\n")
				await originalMessage.channel.send(f"Joining your voice chat")
			except discord.errors.ClientException:
				logging.info(f"User ID: {originalMessage.author.id} - Unsuccessfully Requested joining of voice channel: {originalMessage.author.voice.channel}\n")
				await originalMessage.channel.send("Sorry, looks like I'm in another voice chat")
		else:
			await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")

# Function will make the bot leave its current voice channel, if it is in one
async def vcLeave(originalMessage):
	async with originalMessage.channel.typing():
		if originalMessage.guild.voice_client:
			logging.info(f"User ID: {originalMessage.author.id} - Requested leaving of voice channel\n")
			await mediaStop(originalMessage)
			await originalMessage.channel.send(f"Leaving my current voice chat...")
			await originalMessage.guild.voice_client.disconnect()
		else:
			logging.info(f"User ID: {originalMessage.author.id} - Unsuccessfully Requested leaving of voice channel\n")
			await originalMessage.channel.send("Sorry, I don't think I'm in a voice chat right now")

# Function will make the bot speak some words out loud in a voice channel
async def ttsSpeak(originalMessage):
	if not originalMessage.author.voice:
		await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")
		return
	
	if not originalMessage.guild.voice_client:
		await vcJoin(originalMessage)
	
	user_content = originalMessage.content[11:].strip()
	
	logging.info(f"User ID: {originalMessage.author.id} - Requested tts of: {user_content}\n")
	
	await text_to_speech(user_content, originalMessage)

# New TTS
async def ttsVoice(originalMessage):
	if not originalMessage.author.voice:
		await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")
		return
	
	wordsToSpeak = originalMessage.content[12:].strip()
	
	isPromptSafe = await is_message_safe(originalMessage.content)
	
	if isPromptSafe:
		logging.info(f"User ID: {originalMessage.author.id} - Requested Google TTS of: {wordsToSpeak}\n")
		
		with open("googleTTSCount.yaml", 'r') as file:
			characterCount = yaml.load(file, Loader=yaml.FullLoader)
		
		characterCount += len(wordsToSpeak)
		
		if (characterCount >= 3000000):
			await originalMessage.channel.send("Sorry, but this message will exceed the free message limit for the month")
			return
		
		characterCount += len(wordsToSpeak)
		
		data = {
			'input': {'text': wordsToSpeak},
			'voice': {'languageCode': 'en-gb', 'name': 'en-GB-Standard-C', 'ssmlGender': 'FEMALE'},
			'audioConfig': {'audioEncoding': 'MP3'},
		}
		
		response = requests.post(
			'https://texttospeech.googleapis.com/v1/text:synthesize?key=' + GOOGLE_API_KEY,
			headers={'Content-Type': 'application/json'},
			data=json.dumps(data)
		)
		
		with open("googleTTSCount.yaml", 'w') as file:
			yaml.dump(characterCount, file)
		
		response_data = response.json()
		
		audio_content = base64.b64decode(response_data['audioContent'])
		with open("tospeak.mp3", "wb") as out:
			out.write(audio_content)
		
		if not originalMessage.guild.voice_client:
			await vcJoin(originalMessage)
		
		originalMessage.guild.voice_client.play(source=discord.FFmpegPCMAudio("tospeak.mp3"))
	else:
		logging.info(f"User ID: {originalMessage.author.id} - Requested Unsafe Google TTS of: {wordsToSpeak}\n")
		await originalMessage.channel.send("Sorry, your message was unsafe. Please review the usage policy: <https://openai.com/policies/usage-policies>")

# Function will make the bot stream audio using yt-dlp
async def mediaAdd(originalMessage):
	async with originalMessage.channel.typing():
		
		guild_id = originalMessage.guild.id
		if guild_id not in mediaQueues:
			mediaQueues[guild_id] = []

		if not originalMessage.author.voice:
			await originalMessage.channel.send("Sorry, you don't seem to be in a voice chat I can access")
			return
		if not originalMessage.guild.voice_client:
			await vcJoin(originalMessage)
			await mediaAdd(originalMessage)
			return

		ydl_opts = {
			'format': 'bestaudio/best',
			'noplaylist': False,
			'quiet': True,
			'age_limit': 17,
			'extract_flat': 'in_playlist,is_live'
		}

		url = originalMessage.content[12:].strip()
		logging.info(f"User ID: {originalMessage.author.id} - Requested Media: {url}\n")

		with yt_dlp.YoutubeDL(ydl_opts) as ydl:
			info = ydl.extract_info(url, download=False)

			# If livestream, do nothing
			is_live = info.get('is_live', False)
			if is_live:
				await originalMessage.channel.send("Sorry, I can't play livestreams")
				return

			# If playlist, add all
			if "entries" in info:
				await originalMessage.channel.send("Playlist detected. Adding songs...")
				for entry in info["entries"]:
					audio_url = entry.get('url')
					video_title = entry.get('title', 'Unknown Title')
					video_url = entry.get('webpage_url')
					await add_to_queue(originalMessage, audio_url, video_title, video_url)

			# If single video, add
			else:
				audio_url = info.get('url')
				video_title = info.get('title', 'Unknown Title')
				video_url = info.get('webpage_url')
				await add_to_queue(originalMessage, audio_url, video_title, video_url)

		if not originalMessage.guild.voice_client.is_playing():
			await play_next(originalMessage)

# Function will make bot pause current media
async def mediaPause(originalMessage):
	voice_client = originalMessage.guild.voice_client

	if not voice_client or not voice_client.is_playing():
		await originalMessage.channel.send("Sorry, I don't seem to be playing anything right now")
		return

	voice_client.pause()
	await originalMessage.channel.send("Pausing your media...")

# Function will make bot continue current media
async def mediaResume(originalMessage):
	voice_client = originalMessage.guild.voice_client

	if not voice_client or not voice_client.is_paused():
		await originalMessage.channel.send("Sorry, I don't seem to be paused right now")
		return

	voice_client.resume()
	await originalMessage.channel.send("Resuming your media...")

# Function will make the bot stop current media
async def mediaStop(originalMessage):
	guild_id = originalMessage.guild.id
	voice_client = originalMessage.guild.voice_client
	
	await originalMessage.channel.send("Ending audio and clearing the queue...")
	
	if not voice_client or not (voice_client.is_playing() or voice_client.is_paused()):
		await originalMessage.channel.send("Sorry, I don't seem to be playing anything right now")
		return
	
	mediaQueues[guild_id] = [] # Clear the queue for the guild
	voice_client.stop()

# Function will make the bot skip to the next item in the queue
async def mediaSkip(originalMessage):
	guild_id = originalMessage.guild.id
	voice_client = originalMessage.guild.voice_client

	if not voice_client or not voice_client.is_playing():
		await originalMessage.channel.send("Sorry, I don't seem to be playing anything right now")
		return

	voice_client.stop()
	await originalMessage.channel.send("Skipping to the next item...")
	await play_next(guild_id)

# Function will make the bot show the current queue
async def mediaQueue(originalMessage):
	async with originalMessage.channel.typing():
		guild_id = originalMessage.guild.id
		queue = mediaQueues.get(guild_id, [])

		if not queue:
			await originalMessage.channel.send("The queue is currently empty")
			return

		queue_text = "**Coming Up:**\n```md\n"
		for i, (audio_url, requester_name, video_title, video_url) in enumerate(queue, start=1):
			queue_text += f"{i}. {video_title} - Requested by: {requester_name}\n"
		queue_text += "```"

		await originalMessage.channel.send(queue_text)

# Function will remove the item at a given slot from the queue
async def mediaCancel(originalMessage):
	guild_id = originalMessage.guild.id
	serverQueue = mediaQueues.get(guild_id, [])
	
	index = int(originalMessage.content[14:].strip())

	if not serverQueue:
		await originalMessage.channel.send("The queue is currently empty")
		return

	try:
		removed_item = serverQueue.pop(index - 1)
		await originalMessage.channel.send(f"Removed item #{index} from the queue.")
		await mediaQueue(originalMessage)
	except IndexError:
		await originalMessage.channel.send(f"Sorry, couldn't item #{index}.")
		await mediaQueue(originalMessage)

# Function will clear part/all of the message history the bot has stored for a specific channel
async def chatForget(originalMessage, modelRequested):
	async with originalMessage.channel.typing():
		if (modelRequested == "gpt-4"):
			dictionaryKey = originalMessage.channel.id * -1
		else:
			dictionaryKey = originalMessage.channel.id

		if (dictionaryKey in chatHistories) or (dictionaryKey in webHistories):
			if originalMessage.content.lower().startswith('inkbot4'):
				user_content = originalMessage.content[15:].strip()
			elif originalMessage.content.lower().startswith('inkbot'):
				user_content = originalMessage.content[14:].strip()
			
			if not user_content:
				chatHistories.pop(dictionaryKey)
				saveHistory()
				await originalMessage.channel.send("Understood, clearing all memory from this channel and reverting to my default personality.")
			elif user_content == 'web':
				if dictionaryKey in webHistories:
					webHistories.pop(dictionaryKey)
					saveWebHistory()
					await originalMessage.channel.send("Understood, clearing all data obtained from the web in this channel.")
				else:
					await originalMessage.channel.send("Sorry, I couldn't find any data obtained from the web in this channel.")
			else:
				numToErase = int(user_content) * 2
				for i in range(numToErase):
					chatHistories[dictionaryKey].pop(2)
				saveHistory()
				await originalMessage.channel.send("Understood, clearing " + user_content + " prompts and their responses from this channel.")
		else:
			await originalMessage.channel.send("Sorry, I couldn't find any memories or web data from this channel.")

# Function will override the chatbot's default personality
async def chatBecome(originalMessage, modelRequested):
	async with originalMessage.channel.typing():
		logging.info(f"User ID: {originalMessage.author.id} - Submitted New Personality: {originalMessage.content}\n")
		
		if (modelRequested == "gpt-4"):
			dictionaryKey = originalMessage.channel.id * -1
		else:
			dictionaryKey = originalMessage.channel.id
		
		if originalMessage.content.lower().startswith('inkbot4:'):
			newPersonality = originalMessage.content[15:].strip()
		elif originalMessage.content.lower().startswith('inkbot:'):
			newPersonality = originalMessage.content[14:].strip()
		else:
			newPersonality = originalMessage.content

		custom_system_message = [
			{"role": "system", "content": newPersonality},
			{"role": "system", "content": TEXT_FORMAT},
		]

		if dictionaryKey not in chatHistories:
			chatHistories[dictionaryKey] = custom_system_message.copy()
			saveHistory()
			await originalMessage.channel.send("Successfully adopted my new personality.")
		else:
			chatHistories.pop(dictionaryKey)
			chatHistories[dictionaryKey] = custom_system_message.copy()
			saveHistory()
			await originalMessage.channel.send("Successfully cleared all memories of this channel and adopted my new personality.")

# Function will call chatBecome with some preset personality
async def chatSelect(originalMessage, modelRequested):
	async with originalMessage.channel.typing():
	
		tempMessage = originalMessage
	
		if originalMessage.content.lower().startswith('inkbot4:'):
			user_content = originalMessage.content[15:].strip()
		elif originalMessage.content.lower().startswith('inkbot:'):
			user_content = originalMessage.content[14:].strip()
		else:
			user_content = originalMessage.content
	
		if not user_content:
			await originalMessage.channel.send("Please include the pre-defined personality you would like me to adopt.")
		elif user_content.lower() == 'original':
			await originalMessage.channel.send("Setting predefined personality: original.")
			tempMessage.content = SELECT_ORIGINAL
		elif user_content.lower() == 'art prompt':
			await originalMessage.channel.send("Setting predefined personality: art prompt generator")
			tempMessage.content = SELECT_ARTPROMPT
		elif user_content.lower() == 'lovesick':
			await originalMessage.channel.send("Setting predefined personality: lovesick")
			tempMessage.content = SELECT_LOVESICK
		elif user_content.lower() == 'uwu':
			await originalMessage.channel.send("Setting predefined personality: UWU")
			tempMessage.content = SELECT_UWU
		else:
			await originalMessage.channel.send("Sorry, that does not appear to be one of my pre-defined personalities.")
			return

		await chatBecome(tempMessage, modelRequested)

# Function will add the channel to a list of sessions
async def chatSession(originalMessage, modelRequested):
	if originalMessage.channel.type is discord.ChannelType.text:
		webhook = await originalMessage.channel.create_webhook(name="inkBOTWebhook")
	
	if (modelRequested == "gpt-4"):
		dictionaryKey = originalMessage.channel.id * -1
	else:
		dictionaryKey = originalMessage.channel.id
	
	if ((dictionaryKey in chatSessions) or ((dictionaryKey * -1) in chatSessions)):
		await originalMessage.channel.send("It seems like a session is already running in this channel, please end the current session before starting a new one")
	else:
		chatSessions[dictionaryKey] = (1, 0.1, 0, 0, False, "inkBOT", "https://cdn.discordapp.com/embed/avatars/0.png")
		saveSessions()
		
		await originalMessage.channel.send("Session started. All non-commands will now be considered prompts for the chatbot. Use `inkbot: session stop` to end your session")

# Function will remove the channel from the list of sessions
async def chatSessionEnd(originalMessage, modelRequested):
	if (modelRequested == "gpt-4"):
		dictionaryKey = originalMessage.channel.id * -1
	else:
		dictionaryKey = originalMessage.channel.id
	
	if dictionaryKey in chatSessions:
		if originalMessage.channel.type is discord.ChannelType.text:
			webhooks = await originalMessage.channel.webhooks()
			for webhook in webhooks:
				if webhook.name == "inkBOTWebhook":
					await webhook.delete()
		
		chatSessions.pop(dictionaryKey)
		saveSessions()
		
		await originalMessage.channel.send("The session has ended. Chatbot will no longer consider non-commands as prompts. Use `inkbot: session start` to begin a new session")
	elif (dictionaryKey * -1) in chatSessions:
		await originalMessage.channel.send("A session using that chatbot is not currently in place. Perhaps you meant inkbot/inkbot4?")
	else:
		await originalMessage.channel.send("Sorry, it does not seem like a session is currently in place.")

# Function will set custom settings for the session
async def chatSessionModify(originalMessage, modelRequested):
	# Get corresponding dictionary key for channel
	if (modelRequested == "gpt-4"):
		dictionaryKey = originalMessage.channel.id * -1
	else:
		dictionaryKey = originalMessage.channel.id
	
	# Return error if not currently in a session
	if dictionaryKey not in chatSessions:
		await originalMessage.channel.send("Please begin a session using `inkbot: session start` before using this command.")
		return
	
	# Obtain current session values
	tempWanted, toppWanted, presenceWanted, frequencyWanted, customWanted, nameWanted, pictureWanted = chatSessions[dictionaryKey]
	
	# Extract settings
	if originalMessage.content.lower().startswith('inkbot4:'):
			user_content = originalMessage.content[23:].strip()
	elif originalMessage.content.lower().startswith('inkbot:'):
		user_content = originalMessage.content[22:].strip()
	else:
		user_content = originalMessage.content
	
	# Determine which setting is being changed, then set the settings
	if user_content.lower().startswith('temperature'):
		user_content = user_content[11:]
		tempWanted = float(user_content)
		if (tempWanted >= 0) and (tempWanted <= 2):
			toppWanted = 1
			await originalMessage.channel.send(f"Setting temperature to {tempWanted}")
		else:
			await originalMessage.channel.send(f"Value must be between [0, 2]")
	elif user_content.lower().startswith('top_p'):
		user_content = user_content[5:]
		toppWanted = float(user_content)
		if (toppWanted > 0) and (toppWanted <= 1):
			tempWanted = 1
			await originalMessage.channel.send(f"Setting top_p to {toppWanted}")
		else:
			await originalMessage.channel.send(f"Value must be between (0, 1]")
	elif user_content.lower().startswith('presencepenalty'):
		user_content = user_content[15:]
		presenceWanted = float(user_content)
		if (presenceWanted >= -2) and (presenceWanted <= 2):
			await originalMessage.channel.send(f"Setting presence_penalty to {presenceWanted}")
		else:
			await originalMessage.channel.send(f"Value must be between [-2, 2]")
	elif user_content.lower().startswith('frequencypenalty'):
		user_content = user_content[16:]
		frequencyWanted = float(user_content)
		if (frequencyWanted >= -2) and (frequencyWanted <= 2):
			await originalMessage.channel.send(f"Setting frequency_penalty to {frequencyWanted}")
		else:
			await originalMessage.channel.send(f"Value must be between [-2, 2]")
	
	elif user_content.lower().startswith('name'):
		if originalMessage.channel.type is not discord.ChannelType.text:
			await originalMessage.channel.send(f"Sorry, custom names and avatars are only available in normal server text channels")
			return
		nameWanted = user_content[5:]
		customWanted = True
		await originalMessage.channel.send(f"Setting name to {nameWanted}")
	elif user_content.lower().startswith('avatar'):
		if originalMessage.channel.type is not discord.ChannelType.text:
			await originalMessage.channel.send(f"Sorry, custom names and avatars are only available in normal server text channels")
			return
		pictureWanted = user_content[7:]
		customWanted = True
		await originalMessage.channel.send(f"Setting avatar to {pictureWanted}")
	else:
		await originalMessage.channel.send(f"Sorry, could not find that setting. The available settings are: `temperature`, `top_p`, `presencepenalty`, `frequencypenalty`, `name`, and `avatar`.")
	
	# Update session values
	chatSessions[dictionaryKey] = (tempWanted, toppWanted, presenceWanted, frequencyWanted, customWanted, nameWanted, pictureWanted)
	saveSessions()

# Function will generate and post an image in response to an input prompt
async def dallePost(originalMessage):
	async with originalMessage.channel.typing():
		try:
			image_response = openai.Image.create(
				prompt = originalMessage.content[12:].strip(), 
				n = 1, 
				size = "1024x1024" # Can be 256, 512, 1024
			)
			logging.info(f"User ID: {originalMessage.author.id} - Requested Image: {originalMessage.content}, ")
			logging.info(f"received {image_response['data'][0]['url']}\n")
			await originalMessage.channel.send("Image generated!\n> **Prompt:** " + originalMessage.content[12:].strip())
			await originalMessage.channel.send(image_response['data'][0]['url'])
		except InvalidRequestError:
			await originalMessage.channel.send("Sorry, your prompt was unsafe. Please review the content policy: <https://labs.openai.com/policies/content-policy>")
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Unsafe Image Prompt: {originalMessage.content}, ")

# Function will add the first 4000 characters of a wikipedia page to seperate memory
async def chatLearn(originalMessage, modelRequested):
	async with originalMessage.channel.typing():
		if (modelRequested == "gpt-4"):
			dictionaryKey = originalMessage.channel.id * -1
			topic = originalMessage.content[14:].strip()
		else:
			dictionaryKey = originalMessage.channel.id
			topic = originalMessage.content[13:].strip()
		
		logging.info(f"User ID: {originalMessage.author.id} - Requested wikipedia: {topic}\n")

		response = requests.get(
			'https://en.wikipedia.org/w/api.php',
			params={
				'action': 'query',
				'format': 'json',
				'titles': topic,
				'prop': 'extracts',
				# 'exintro': True,
				'explaintext': True,
			}
		).json()

		page = next(iter(response['query']['pages'].values()))
		page = page['extract'][:4000]
				
		webHistories[dictionaryKey] = ([
			{"role": "system", "content": 'Consider the following additional information:  ' + page}
		])
		
		saveWebHistory()
		
		await originalMessage.channel.send(f"Additional information was stored")
		return

# Function will generate a response to some input prompt
async def chatPost(originalMessage, modelRequested):
	async with originalMessage.channel.typing():
		isPromptSafe = await is_message_safe(originalMessage.content)

		# If the prompt passes moderation
		if isPromptSafe:
			
			# Extract prompt from message (remove command)
			if originalMessage.content.lower().startswith('inkbot,'):
				user_content = originalMessage.content[7:].strip()
			elif originalMessage.content.lower().startswith('inkbot4,'):
				user_content = originalMessage.content[8:].strip()
			else:
				user_content = originalMessage.content
			
			# Log prompt
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Prompt: {user_content}\n")
			
			# Get corresponding dictionary key for channel
			if (modelRequested == "gpt-4"):
				dictionaryKey = originalMessage.channel.id * -1
			else:
				dictionaryKey = originalMessage.channel.id

			# If no history for that channel, create one
			if dictionaryKey not in chatHistories:
				chatHistories[dictionaryKey] = defaultHistoryEntry.copy()

			messageToSend = f"""{originalMessage.author.display_name} (may also be referred to as {originalMessage.author.name}) says: "{user_content}" """
						
			# If session, obtain custom variables
			if dictionaryKey in chatSessions:
				tempWanted, toppWanted, presenceWanted, frequencyWanted, customWanted, nameWanted, pictureWanted = chatSessions[dictionaryKey]
			else:
				tempWanted = 1
				toppWanted = 0.1
				presenceWanted = 0
				frequencyWanted = 0
				customWanted = False
			
			# Obtain new date/time information
			current_date = datetime.datetime.now().strftime("%B %d, %Y")
			current_time = datetime.datetime.now().strftime("%I:%M:%S %p")
			time_of_response = f"""The current date is {current_date}. The current time is {current_time}. """
			
			# Generate a response from OpenAI and scan it
			response = await generateCompletion(dictionaryKey, messageToSend, time_of_response, modelRequested, tempWanted, toppWanted, presenceWanted, frequencyWanted)
			
			ResponseSafe = await is_message_safe(response)

			if ResponseSafe:
				logging.info(f"Response: {response}\n")
				
				# Limit GPT-4's memory to save on model costs
				if ((len(chatHistories[dictionaryKey]) >= 12) and (modelRequested == "gpt-4")):
					for i in range(2):
						chatHistories[dictionaryKey].pop(2)
				
				# Extend history with new message + response, then save to the YAML file
				chatHistories[dictionaryKey].extend([
					{"role": "user", "content": time_of_response + messageToSend},
					{"role": "assistant", "content": response},
				])
				saveHistory()
				
				# Obtain the webhook for the custom profile if and send there if requested
				if (customWanted and originalMessage.channel.type is discord.ChannelType.text):
					webhooks = await originalMessage.channel.webhooks()
					for webhook in webhooks:
						if webhook.name == "inkBOTWebhook":
							await webhook.send(
								response,
								username=nameWanted,
								avatar_url=pictureWanted
							)
					return
				
				# Use the custom function if the response is over 2000 characters
				if len(response) > 2000:
					await send_long_message(response, originalMessage.channel)
				else:
					await originalMessage.channel.send(response)
			
			# If the response fails moderation
			else:
				logging.info(f"Unsafe Response Generated: {response}\n")
				await originalMessage.channel.send("Sorry, the generated response was unsafe, I am not allowed to send this")
		
		# If the prompt fails moderation
		else:
			logging.info(f"User ID: {originalMessage.author.id} - Submitted Unsafe Prompt: {originalMessage.content}\n")
			await originalMessage.channel.send("Sorry, your prompt was unsafe. Please review the usage policy: <https://openai.com/policies/usage-policies>")

async def generateCompletion(dictionaryKey, messageText, time_of_response, modelWanted, tempWanted, toppWanted, presenceWanted, frequencyWanted):	
	# Compile data to send to OpenAI
	
	if dictionaryKey not in webHistories:
		completionText = chatHistories[dictionaryKey] + [{"role": "system", "content": time_of_response}] + [{"role": "user", "content": messageText}]
	else:
		completionText = chatHistories[dictionaryKey] + webHistories[dictionaryKey] + [{"role": "system", "content": time_of_response}] + [{"role": "user", "content": messageText}]
	
	# Attempt to generate a response
	try:
		Completion = openai.ChatCompletion.create(
			model=modelWanted,
			messages=completionText,
			temperature=tempWanted,
			top_p=toppWanted,
			presence_penalty=presenceWanted,
			frequency_penalty=frequencyWanted
		)
	except InvalidRequestError:
		# Usually occurs when context limit is surpassed
		# Delete items from memory
		for i in range(8):
			chatHistories[dictionaryKey].pop(2)
		
		# Re-compile data to send to OpenAI
		if dictionaryKey not in webHistories:
			completionText = chatHistories[dictionaryKey] + [{"role": "system", "content": time_of_response}] + [{"role": "user", "content": messageText}]
		else:
			completionText = chatHistories[dictionaryKey] + webHistories[dictionaryKey] + [{"role": "system", "content": time_of_response}] + [{"role": "user", "content": messageText}]
		
		# Attempt to generate a response
		Completion = openai.ChatCompletion.create(
			model=modelWanted,
			messages=completionText,
			temperature=tempWanted,
			top_p=toppWanted,
			presence_penalty=presenceWanted,
			frequency_penalty=frequencyWanted
		)
	except APIError:
		return "There is currently an issue with the OpenAI Servers. Please see https://status.openai.com/"
	except APIConnectionError:
		return "There was an issue connecting to the OpenAI Servers, please try again later"
	except RateLimitError:
		return "Sorry, the rate limit has been exceeded, please try again"
	except Timeout:
		return "Sorry, the request timed out, please try again"
	except ServiceUnavailableError:
		return "There is currently an issue with the OpenAI Servers. Please see https://status.openai.com/"
	except AuthenticationError:
		return "There appears to be a problem with the API key"
	
	return Completion.choices[0].message.content.strip()

async def generate_tts_file(message):
	engine = pyttsx3.init()
	voices = engine.getProperty('voices')
	engine.setProperty('voice', voices[0].id)

	if os.path.exists('tospeak.wav'):
		os.remove('tospeak.wav')

	engine.save_to_file(message, 'tospeak.wav')
	engine.runAndWait()

	engine.stop()

async def text_to_speech(message, original_message):
	await generate_tts_file(message)
	
	while not os.path.exists('tospeak.wav'):
		await asyncio.sleep(0.1)
	
	current_size = os.path.getsize('tospeak.wav')
	await asyncio.sleep(2)
	new_size = os.path.getsize('tospeak.wav')
	
	while current_size != new_size:
		current_size = new_size
		await asyncio.sleep(2)
		new_size = os.path.getsize('tospeak.wav')
	
	original_message.guild.voice_client.play(source = discord.FFmpegPCMAudio('tospeak.wav'))

async def is_message_safe(message):
	response = openai.Moderation.create(
		input = message
	)

	results = response["results"]
	flagged = results[0]["flagged"]
	logging.info(f"Were scanned contents flagged? {flagged}\n")
	return not flagged

async def add_to_queue(originalMessage, audio_url, video_title, video_url):
	guild_id = originalMessage.guild.id
	requester_name = originalMessage.author.name
	mediaQueues[guild_id].append((audio_url, requester_name, video_title, video_url))
	await originalMessage.channel.send(f"Added {video_title} to the queue!")

async def play_next(originalMessage):
	guild_id = originalMessage.guild.id
	voice_client = originalMessage.guild.voice_client
	
	if not mediaQueues[guild_id]:
		return
	if not voice_client:
		return
	
	audio_url, requester_name, video_title, video_url = mediaQueues[guild_id].pop(0)
	voice_client.stop()
	
	FFMPEG_OPTIONS = {
		'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
		'options': '-vn'
	}
	
	await originalMessage.channel.send("**Now Playing:** " + video_url + "\n**Requested by:** " + originalMessage.author.display_name + " (" + originalMessage.author.name + ")")
	
	voice_client.play(FFmpegPCMAudio(executable="ffmpeg", source=audio_url, **FFMPEG_OPTIONS), after=lambda e: asyncio.run_coroutine_threadsafe(play_next(originalMessage), voice_client.loop))
	voice_client.source = discord.PCMVolumeTransformer(voice_client.source)
	voice_client.source.volume = 0.1

async def checkAlone(guild, voice_client):
	while True:
		members = voice_client.channel.members
		non_bots = [member for member in members if not member.bot]
		
		# If no humans present, check again in 20 seconds. If no humans present then, leave
		await asyncio.sleep(20)
		members = voice_client.channel.members
		non_bots = [member for member in members if not member.bot]
		
		if len(non_bots) == 0:
			while voice_client.is_playing():
				voice_client.stop()
			await voice_client.disconnect()
			break

def saveHistory():
	with open("storedHistories.yaml", 'w') as file:
		file.write(yaml.dump({'chatHistories': chatHistories}, sort_keys=False))

def saveWebHistory():
	with open("storedWebHistories.yaml", 'w') as file:
		file.write(yaml.dump({'webHistories': webHistories}, sort_keys=False))

def saveSessions():
	with open("storedSessions.yaml", 'w') as file:
		file.write(yaml.dump({'sessionList': chatSessions}, sort_keys=False))